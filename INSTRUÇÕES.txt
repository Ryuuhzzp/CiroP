PORT ANDROID 64-BIT MONOGAME (CELESTE/MONOCLE) COM ASSETS INSTALÁVEIS NA PRIMEIRA EXECUÇÃO (DOWNLOAD/EXTRAÇÃO DE Content.zip), UI INICIAL EM FLUTTER (DARK MODE OBRIGATÓRIO + LANDSCAPE + FULLSCREEN), HOST KOTLIN (ANDROID), JOGO MONOGAME EM C# (SEM PROJETO DESKTOP), TELA CHEIA NATIVA, FPS COUNTER, LOGSYSTEM COMPLETO (BOOT + RUNTIME + CRASH LOGS), EXPORT/IMPORT DE SAVES E LOGS VIA SAF, INPUT: TECLADO/MOUSE/CONTROLE FÍSICO + CONTROLES NA TELA OPCIONAIS CONFIGURÁVEIS, FMOD/ÁUDIO PRESERVADO (ARM64), RELATORIO.md ÚNICO (ATUALIZADO CONTINUAMENTE) E BUGFIX LOOP

REFERÊNCIA OFICIAL MONOGAME (OBRIGATÓRIA) Use como referência principal para templates, estrutura e decisões técnicas (compatibilidade, host Android, padrões de GameActivity, input, ciclo de vida, e recomendações modernas) o repositório oficial do MonoGame: https://github.com/MonoGame/MonoGame

ESTUDO OBRIGATÓRIO ANTES DE COMEÇAR (SEM PULAR) Antes de modificar qualquer arquivo, você deve estudar e absorver:

1. Documentação Flutter (Add-to-App, Platform Channels, integração Android nativa, lifecycle): https://docs.flutter.dev/


2. Documentação MonoGame: https://docs.monogame.net/


3. Tutorial introdutório MonoGame (arquitetura e ciclo de jogo): https://docs.monogame.net/articles/tutorials/building_2d_games/01_what_is_monogame/index.html


4. Referência .NET para mobile (conceitos e tooling): https://dotnet.microsoft.com/pt-br/apps/mobile


5. Página de contexto (não é fonte técnica do port; usar apenas como referência de contexto): https://www.crieseusjogos.com.br/ferramentas-criar-celeste/


6. FMOD (download, runtime nativo, integração em Android/arm64, licenciamento): https://www.fmod.com/ https://www.fmod.com/download#



Depois de estudar os links, você deve estudar a estrutura do repositório decompilado (árvore, arquivos, padrões de IO, padrões de Content, áudio, input, reflexão, saves) e escrever uma auditoria inicial no RELATORIO.md antes de iniciar a ETAPA 1.

NOME DO APLICATIVO E PACOTE (OBRIGATÓRIO) Nome do Aplicativo (label): Celeste Nome do Pacote / ApplicationId (obrigatório): Celestemeown.app

ARTEFATO DE ENTRADA (REPO DECOMPILADO) O repositório contém o código decompilado com estas pastas/arquivos relevantes que você deve considerar e não esquecer: Celeste/ Monocle/ SimplexNoise/ FMOD/ e FMOD.Studio/ (bindings C#) Celeste.Editor/ (editor/preview) Celeste.Pico8/ Properties/AssemblyInfo.cs Celeste.csproj (net45, x86, refs_dlls XNA) app.config, app.ico Content/ (pode existir no repo, mas o app final NÃO deve depender de Content embutido no APK; o fluxo é Content.zip)

FATOS TÉCNICOS CONFIRMADOS NO CÓDIGO (TRATAR COMO VERDADE NO PORT)

1. Paths/ContentDirectory: Monocle/Engine.cs usa AssemblyDirectory/ContentDirectory baseado em Assembly.Location (desktop) e File IO direto. Isso quebra no Android e deve ser substituído por serviço de plataforma.


2. Carregamento misto: Há carregamento misto: muitos assets por FileStream (PNG, .bin/.data, .fnt/.xml/.txt) e alguns por ContentManager (XNB) em: Monocle/VirtualTexture.cs (Texture2D) Monocle/Draw.cs (SpriteFont) Celeste/GFX.cs (Effect)


3. FMOD: Celeste/Audio.cs usa FMOD e aponta bancos para FMOD/Desktop no ContentDirectory. No Android, os bancos devem estar em filesystem real (assets instalados) e o path deve ser adaptado para layout Android (ex.: FMOD/Android) ou para a pasta real extraída.


4. Input: Input atual depende de Keyboard/Mouse (Monocle/MInput.cs) e há binds de teclado em Celeste/Input.cs e Celeste/Settings.cs. Isso deve continuar funcionando no Android com periféricos físicos (BT/USB) via MonoGame.


5. Reflexão: Overworld.cs usa reflexão (Assembly.GetExecutingAssembly().GetTypes()) e existem outros pontos de reflexão/registro dinâmico no projeto (ex.: Commands/Tracker/Pooler/SpawnManager). Isso exige cuidado com trimming/linker no Android para não quebrar.


6. Saves: Saves/UserIO usam File.* com caminhos relativos (ex.: “Saves”). No Android isso deve ser redirecionado para app-specific storage via serviço de plataforma, sem permissões amplas.



OBJETIVO FINAL (O QUE ENTREGAR) Portar o projeto Celeste/Monocle decompilado para Android usando MonoGame Android em .NET moderno, com:

1. APK arm64-v8a (64-bit apenas), sem outras ABIs.


2. Sem projeto Desktop (apenas Mobile/Android).


3. UI inicial em Flutter (modo escuro obrigatório), app travado em landscape, fullscreen real.


4. Host Android em Kotlin coordenando: Flutter UI (Add-to-App) instalação de assets (download + unzip + validação) export/import via SAF fullscreen/landscape início do jogo via GameActivity coleta/export de logs


5. Jogo rodando em C# MonoGame (mgandroid), iniciado somente via botão “Iniciar Jogo” na UI.


6. Assets NÃO embutidos no APK: Content.zip será baixado e instalado na primeira execução, com confirmação do usuário, progresso e validação forte. O jogo só dá boot depois de assets instalados e validados.


7. FMOD/áudio preservado (música e SFX): Proibido remover, silenciar, “stubbar” ou desativar áudio.


8. LogSystem completo: Logs de boot, runtime e crash logs persistentes com data/hora. Exportáveis pela UI via SAF e também coletáveis via ADB.


9. FPS Counter: Contador básico (média por segundo) toggle via UI, overlay no canto. Opcional: logging periódico de FPS somente se “verbose logs” estiver habilitado.


10. Input completo: Teclado + mouse + controle físico (USB/BT). Controles na tela opcionais (overlay) configuráveis via UI, sem quebrar o input original do jogo.


11. Um único RELATORIO.md: Atualizado continuamente (proibido criar relatórios paralelos).



LINK DOS ASSETS (CONTENT) (OBRIGATÓRIO) Content.zip deve ser obtido deste link (download dentro do app): https://github.com/augustjose034-sketch/CODESPACE-/releases/download/X1/Content.zip

FMOD ANDROID SDK (OBRIGATÓRIO COMO FONTE DO RUNTIME NATIVO) Você deve usar este pacote como origem do runtime nativo FMOD para Android: https://github.com/portceleste8-sketch/CELESTE-GAME-ANDROID-/releases/download/V1/fmodstudioapi20312android.tar.gz

Regras para o FMOD: Extrair esse pacote e incorporar SOMENTE o necessário no repositório final. Incluir SOMENTE arm64-v8a (64-bit). Garantir que os nomes das libs batem com os DllImport do binding C# (fmod / fmodstudio).

ÍCONE DO APP (OBRIGATÓRIO) Ícone do app (baixar e gerar mipmap): https://i.postimg.cc/ZKszRFXK/app.jpg Você deve baixar essa imagem, gerar mipmap-mdpi/hdpi/xhdpi/xxhdpi/xxxhdpi e aplicar como ícone do launcher no projeto Android. Registrar no RELATORIO.md exatamente quais arquivos foram criados/alterados e onde foi aplicado.

ORGANIZAÇÃO DO PROJETO (OBRIGATÓRIA, SEM DESKTOP) Estrutura final esperada: / Celeste.sln RELATORIO.md src/ Celeste.Core/            (Celeste + Monocle + SimplexNoise + código compartilhado e neutro de plataforma) Celeste.Android/         (Android app: Kotlin host + Flutter UI + MonoGame GameActivity em C#) docs/ USO_ANDROID.md LOGS.md TROUBLESHOOTING.md tools/ (opcional)

PROIBIÇÕES E REGRAS ABSOLUTAS

1. Proibido remover áudio do jogo. Proibido substituir por silêncio, stubs ou desativar eventos/sons/música. FMOD deve funcionar no Android.


2. Proibido remover lógicas essenciais do game. Ajustes apenas para compatibilidade, paths, lifecycle e integração com plataforma.


3. 64-bit only: apenas arm64-v8a. Proibido incluir armeabi-v7a, x86, x86_64.


4. Assets não são embutidos no APK: o app baixa Content.zip e instala internamente na primeira execução (ou via “Reinstalar Assets”).


5. Proibido MANAGE_EXTERNAL_STORAGE.


6. Permissões: usar o mínimo possível e somente as justificáveis para recursos reais do app. Export/Import deve usar SAF (Document Picker), sem READ/WRITE_EXTERNAL_STORAGE.


7. Proibido espalhar #if ANDROID no Core. Centralizar diferenças via serviços/interfaces e/ou separação por projeto.


8. Flutter e Kotlin são camadas de UI/host; não podem bloquear o build final. Se Flutter Add-to-App causar instabilidade, reduzir e estabilizar (fallback para UI Kotlin mínima) sem impedir o jogo de rodar.


9. Proibido criar “vários relatórios”. Apenas RELATORIO.md único e continuamente atualizado.



POLÍTICA DE PERMISSÕES (OBRIGATÓRIA, MÍNIMO NECESSÁRIO) Você NÃO deve solicitar uma lista gigante de permissões (contatos, SMS, chamadas, localização em background, acessibilidade, admin, MANAGE_EXTERNAL_STORAGE etc.). O app deve funcionar com o mínimo.

Permissões permitidas (apenas se usadas de fato):

1. INTERNET e ACCESS_NETWORK_STATE para baixar Content.zip.


2. POST_NOTIFICATIONS somente se realmente implementar notificação de progresso de download (opcional).


3. BLUETOOTH_CONNECT e BLUETOOTH_SCAN somente se implementar fluxo que realmente exija (Android 12+), e pedir runtime permission apenas quando necessário. Preferir não pedir se o controle BT funcionar via input padrão.



Armazenamento: Proibido READ_EXTERNAL_STORAGE e WRITE_EXTERNAL_STORAGE como estratégia principal. Export/Import de saves e export de logs deve ser via SAF (ACTION_CREATE_DOCUMENT, ACTION_OPEN_DOCUMENT, DocumentFile), dispensando permissões amplas.

Qualquer permissão extra além disso exige: a) justificativa técnica explícita no RELATORIO.md b) explicação em docs/USO_ANDROID.md c) fluxo de consentimento claro na UI d) prova objetiva de que sem ela o recurso não funciona

RELATORIO.md (ÚNICO, ATUALIZAÇÃO CONTÍNUA, FORMATO OBRIGATÓRIO) Criar apenas um arquivo no root chamado RELATORIO.md e atualizá-lo constantemente. Proibido criar outros relatórios.

Cada entrada deve conter: Etapa/Subetapa Data/hora Objetivo Mudanças (Criados / Alterados / Removidos) Classes/métodos afetados (nomes exatos) O que foi reescrito e por quê (resumo objetivo) O que foi deletado e por quê (resumo objetivo) Motivo técnico (curto) Comandos executados (exatos) Saída resumida (erros/warnings principais) Resultado (passou/falhou) e ação tomada Impacto no app/jogo Próximo passo

Restrições de estilo: Markdown simples sem ASCII art sem “===”, “---”, “_____” sem emojis

ARQUITETURA GERAL (OBRIGATÓRIA) Você deve implementar 3 camadas integradas:

CAMADA A: Flutter UI (Dart) UI inicial e ferramentas (instalação de assets, logs, export/import, config).

CAMADA B: Kotlin (Android host) Activities, integração Flutter (MethodChannel), download/instalação de assets, SAF export/import, fullscreen/landscape, orquestração do fluxo, captura de crash Kotlin.

CAMADA C: C# MonoGame (jogo) GameActivity mgandroid, Game principal, Core neutro (Celeste + Monocle + SimplexNoise), LogSystem C# e integração com paths/content instalado.

Fluxo alto nível:

1. App inicia em MainLauncherActivity (Kotlin) que hospeda Flutter UI (dark, landscape, fullscreen).


2. Flutter UI chama Kotlin via MethodChannel para: instalar assets (download + unzip + validar) ver status de assets exportar/importar saves via SAF ver logs e exportar logs via SAF habilitar/desabilitar FPS counter habilitar/configurar controles na tela iniciar jogo


3. Kotlin inicia GameActivity (MonoGame) somente quando usuário clicar “Iniciar Jogo”, passando: contentRootPath flags de config (fps, verbose, controles na tela)


4. GameActivity inicia o jogo em fullscreen e aponta o conteúdo para o diretório instalado (filesystem).


5. LogSystem existe desde o boot e captura crashes de Kotlin e C#.



FULLSCREEN, LANDSCAPE E MODO ESCURO (OBRIGATÓRIO)

1. Aplicativo inteiro em landscape (deitado). Travar orientação para landscape.


2. Fullscreen real com immersive sticky (sem status bar e sem navigation bar durante uso normal).


3. Reaplicar fullscreen em onResume e onWindowFocusChanged (Kotlin).


4. Flutter UI deve permanecer fullscreen e em dark mode obrigatório (tema escuro fixo).


5. Ao abrir o jogo (MonoGame), garantir fullscreen também e manter após pause/resume.



ASSETS: DOWNLOAD, INSTALAÇÃO, VALIDAÇÃO E REINSTALAÇÃO (OBRIGATÓRIO) Objetivo: APK leve, assets instalados no primeiro uso, com confirmação do usuário.

Diretório de instalação (preferencial): Android: Context.getExternalFilesDir(null)/Celeste/Content/ Motivo: app-specific, sem permissão ampla, acessível via adb pull quando necessário.

Requisitos do instalador:

1. Pré-checagem: verificar espaço disponível estimar espaço após extração (quando possível) mostrar aviso se não houver espaço


2. Download: HTTP robusto (timeout, retry controlado, validação de status) progresso (bytes/total, percent) cancelamento log detalhado


3. Integridade: validar Content-Length quando disponível opcional: SHA-256 se for fornecido (se não houver hash, registrar no RELATORIO.md e confiar em validação estrutural forte)


4. Extração: extração por streaming (não explodir RAM) proteção contra Zip Slip (proibir caminhos com ../, normalizar e restringir ao ContentRoot) criar diretórios de forma segura log de progresso e falhas


5. Pós-extração: CheckContent forte (baseado no código real do jogo) persistir estado (SharedPreferences): assets_instalados, timestamp, validação_ok, versão_do_pack (se definida), last_error (se falhar)


6. Reinstalar assets: opção na UI que apaga a pasta instalada (com confirmação forte) e executa o fluxo completo novamente


7. Bloqueio: o jogo só pode iniciar se CheckContent passar



CHECKCONTENT (VALIDAÇÃO FORTE) (OBRIGATÓRIO) Após instalar, validar a presença de itens críticos compatíveis com o código do Celeste/Monocle:

1. Dialog/ (arquivos de diálogo .txt usados pelo jogo)


2. Fonts/ (arquivos .fnt/.xml + texturas de fonte, se aplicável)


3. Effects/ (efeitos usados pelo GFX.cs e pipeline do MonoGame)


4. Atlases/ ou estrutura equivalente: arquivos esperados por Monocle/Atlas.cs (.bin/.data/.meta e PNG correspondentes)


5. XNBs necessários para pontos que usam ContentManager: SpriteFont XNB usado por Monocle/Draw.cs Effect XNB(s) usados por Celeste/GFX.cs Texturas XNB usadas por VirtualTexture.cs (se existirem no pack)


6. FMOD/: bancos .bank e strings necessários layout Android (FMOD/Android) ou layout compatível com a adaptação feita no Audio.cs



Se faltar algo: bloquear “Iniciar Jogo” mostrar mensagem clara na UI com lista resumida do que falta registrar no LogSystem detalhado (arquivos/pastas faltantes e paths verificados)

CONTENT LOADING NO MONOGAME COM ASSETS EM FILESYSTEM (OBRIGATÓRIO) O jogo usa duas categorias de assets: A) File IO direto (FileStream) para PNG, .bin/.data, .fnt/.xml/.txt, etc. B) ContentManager (XNB) para VirtualTexture/Draw/GFX

Como os assets estarão no filesystem (não no APK assets), você deve:

1. Substituir dependência de Assembly.Location: Monocle/Engine.cs deve obter ContentDirectory/ContentRoot via serviço de plataforma (IPlatformPaths). Proibido usar Assembly.Location no Android.


2. File IO direto: Criar um resolvedor de paths no Core para mapear caminhos relativos do jogo para ContentRoot instalado. Centralizar isso em serviço, não espalhar ifs.


3. XNB no filesystem: Implementar um ContentManager customizado (ex.: ExternalFileContentManager) que consiga abrir XNB via FileStream no ContentRoot instalado. O objetivo é manter chamadas existentes: Engine.Instance.Content.Load<Texture2D>(...) Engine.Instance.Content.Load<SpriteFont>(...) Engine.Instance.Content.Load<Effect>(...) funcionando com XNBs extraídos.



Regras: não depender de TitleContainer.OpenStream para os XNBs principais normalizar separadores e nomes (assetName sem extensão) logar tentativas e paths no LogSystem em modo verbose

4. Estratégia de fallback (robustez): Se um XNB não existir no filesystem, o loader deve retornar erro claro (com log completo), e a UI deve orientar reinstalar assets. Não inventar assets faltantes.



FMOD/ÁUDIO PRESERVADO (OBRIGATÓRIO, ARM64, COM PATH REAL) Regras e implementação:

1. Integrar libs arm64-v8a do FMOD a partir do pacote: https://github.com/portceleste8-sketch/CELESTE-GAME-ANDROID-/releases/download/V1/fmodstudioapi20312android.tar.gz


2. Incluir SOMENTE arm64-v8a: Colocar .so em: src/Celeste.Android/.../jniLibs/arm64-v8a/ Manter apenas: libfmod.so (ou libfmodL.so se debug) libfmodstudio.so (ou libfmodstudioL.so se debug)


3. Binding C# e nomes: Os bindings C# usam DllImport("fmod") e DllImport("fmodstudio"), então o Android deve resolver para libfmod.so e libfmodstudio.so automaticamente.


4. Bancos FMOD: Os bancos devem estar dentro do conteúdo instalado (filesystem real). Celeste/Audio.cs atualmente aponta para FMOD/Desktop. Adaptar para: FMOD/Android (recomendado) dentro do ContentRoot instalado, OU manter a estrutura mas apontar corretamente para a pasta real extraída.


5. Lifecycle: Implementar hooks no Android: OnPause: pausar áudio corretamente (sem matar o sistema) OnResume: retomar áudio corretamente


6. Logs: LogSystem deve registrar: init do FMOD path final dos bancos bancos carregados erros detalhados (código/resultado FMOD, exceções)



LOGSYSTEM (OBRIGATÓRIO, COMPLETO, PERSISTENTE, COM CRASH LOGS) Implementar LogSystem com persistência, organização, captura e export.

1. Pastas e nomes: Android: Context.getExternalFilesDir(null)/Celeste/Logs/ Organizar por data: Logs/YYYY-MM-DD/ Arquivos: session_YYYY-MM-DD_HH-mm-ss.log crash_YYYY-MM-DD_HH-mm-ss.log


2. O que logar (mínimo obrigatório): Boot do app (Kotlin) + versões: app version, build config, device model, Android version, ABI, paths principais Estado de assets: instalado/validado/falha + motivo Download: início/progresso/fim/falhas Extração: início/progresso/fim/falhas + proteção zip-slip CheckContent: resultado + missing items Lifecycle Kotlin: onCreate/onStart/onResume/onPause/onStop/onDestroy Fullscreen/orientação: aplicação e reaplicação Início do jogo: Intent de start, flags, retorno para UI (se houver) MonoGame: init, resolução, backbuffer, viewport FMOD: init, bancos, erros Saves: save/load, export/import FPS: toggle e métricas (condicional em verbose)


3. Crash capture: Kotlin: instalar DefaultUncaughtExceptionHandler e registrar crash log com stacktrace, device info e etapa atual C#: registrar: AppDomain.CurrentDomain.UnhandledException TaskScheduler.UnobservedTaskException Em crash: flush imediato crash log separado incluir inner exceptions, última etapa/ação, flags (fps/verbose/touch overlay), estado do content instalado


4. Performance: LogSystem deve usar buffer/fila e flush controlado para não travar o jogo. Em crash: flush síncrono obrigatório.


5. Exportação: Exportar logs via UI usando SAF: Kotlin cria zip do diretório Logs (ou dia selecionado) ACTION_CREATE_DOCUMENT para o usuário escolher destino Registrar no LogSystem a operação e resultado



docs/LOGS.md deve explicar: onde os logs ficam como puxar via ADB: adb pull /sdcard/Android/data/Celestemeown.app/files/Celeste/Logs/ como exportar via UI como interpretar session vs crash

FPS COUNTER (OBRIGATÓRIO)

1. Implementar FPS médio por 1 segundo. Observação técnica do código: Monocle/Engine.cs já mantém um FPS interno; você pode reaproveitar esse valor e apenas desenhar overlay.


2. Toggle via UI: Flutter toggle -> Kotlin -> persistir (SharedPreferences) -> passar flag para GameActivity -> C# habilita/desabilita overlay.


3. Overlay: Desenhar texto simples no canto superior. Não depender de touch. Sem UI complexa.


4. Log periódico (opcional): Somente se “verbose logs” estiver ligado, logar FPS médio a cada 10s.



UI EM FLUTTER (OBRIGATÓRIA, ADD-TO-APP) Requisitos:

1. Dark mode obrigatório (tema escuro fixo).


2. Landscape obrigatório.


3. Fullscreen (sem barras) também na UI.


4. UI inicial não inicia o jogo automaticamente.


5. Cards/opções organizadas com título e descrição.



Seções mínimas obrigatórias (com descrição):

1. Status/Instalação de Assets: mostrar instalado/não instalado, última validação, botão instalar/reinstalar


2. Iniciar Jogo: somente habilitado se assets validados


3. Logs: listar sessões/crash, abrir detalhes, exportar logs (zip) via SAF


4. Contador de FPS: toggle + indicação do estado


5. Reinstalar Assets: confirmação forte, apaga e reinstala


6. Save Data Export/Import: export zip via SAF, import zip via SAF, confirmação


7. Input: Controles na tela (toggle) + configuração básica de layout (posicionamento/tamanho simplificado) e salvar config


8. Informações do Projeto: versão do app, build config, device info, ABI, paths (ContentRoot/Saves/Logs), status FMOD (ok/erro)


9. Configurações: verbose logs, limpar logs antigos, limpar cache temporário, reset configurações



Comunicação Flutter -> Kotlin:

1. MethodChannel com nome fixo, ex.: "celeste.host/channel"


2. Métodos mínimos: getStatus() installAssets() reinstallAssets() startGame() setFpsEnabled(bool) setVerboseLogs(bool) setOnScreenControlsEnabled(bool) setOnScreenControlsConfig(json) exportLogs() exportSaves() importSaves() openLogsList() readLogFile(path/id)


3. Respostas estruturadas: success: true/false message: string details: map (opcional) Sempre logar cada chamada no LogSystem.



HOST KOTLIN (OBRIGATÓRIO) Implementar em Kotlin:

1. MainLauncherActivity: LAUNCHER, hospeda Flutter UI (Add-to-App). Inicializa FlutterEngine, registra MethodChannel, aplica fullscreen/landscape/dark.


2. AssetInstaller: download do Content.zip do link fixo progresso para Flutter extração segura (zip-slip safe) instalação em ContentRoot app-specific CheckContent forte persistência do estado em SharedPreferences


3. SAF helpers: export logs: zip Logs -> ACTION_CREATE_DOCUMENT export saves: zip Saves -> ACTION_CREATE_DOCUMENT import saves: ACTION_OPEN_DOCUMENT -> extrair e restaurar com confirmação


4. Fullscreen: immersive sticky aplicado e reaplicado: onResume onWindowFocusChanged


5. Lock landscape: travar orientação


6. Crash Kotlin: DefaultUncaughtExceptionHandler para gravar crash log em Logs/ do app-specific


7. Start Game: iniciar GameActivity (MonoGame/C#) via Intent com extras: contentRootPath savesRootPath logsRootPath fpsEnabled verboseLogs onScreenControlsEnabled onScreenControlsConfigPath ou json serializado



C# / MONOGAME (JOGO) (OBRIGATÓRIO) Implementar com templates oficiais mgandroid.

1. Projetos: Celeste.Core: contém Celeste + Monocle + SimplexNoise + bindings C# de FMOD (sem código Android específico) Celeste.Android: contém host Android (Kotlin + Flutter + integração) e o GameActivity MonoGame em C#


2. Paths: Criar interfaces no Core: IPlatformPaths (ContentRoot, SavesRoot, LogsRoot) IAssetLocator (resolver caminhos relativos do jogo) ILogSystem (API comum) Implementação Android injeta paths reais via extras/serviço.


3. Engine.ContentDirectory: Remover dependência de Assembly.Location. Engine deve usar ContentRoot instalado.


4. XNB filesystem: Implementar ExternalFileContentManager (ContentManager custom) para abrir XNB via FileStream no ContentRoot. Garantir que VirtualTexture/Draw/GFX funcionem sem mudar as chamadas originais.


5. Fullscreen/resolução: No Android, inicializar em fullscreen. Configurar backbuffer/viewport conforme resolução real. Não alterar lógica de colisão/física; ajustar apenas escala/render. Logar resolução/backbuffer/viewport.


6. Input: Manter Keyboard/Mouse/GamePad. Controles na tela opcionais: overlay desenhado por cima não substitui o input físico config persistida em app-specific UI controla toggle/config


7. Logs: LogSystem C# ativo desde o início do Game. Capturar exceptions e logar.



SAVES E DADOS (APP-SPECIFIC, SEM PERMISSÃO AMPLA)

1. Base de saves: Android: Context.getExternalFilesDir(null)/Celeste/Saves/ Core deve escrever/ler sempre via serviço de paths.


2. Export/Import via SAF: Export: zip da pasta Saves -> ACTION_CREATE_DOCUMENT Import: selecionar zip -> extrair e substituir/mesclar conforme política definida (com confirmação) Logar tudo.



REFLEXÃO/LINKER (OBRIGATÓRIO) Como existe reflexão em vários pontos (Overworld e outros), o build Android deve evitar quebrar o jogo por trimming/linker. Regras:

1. Preferir desativar trimming para o assembly do jogo se necessário (abordagem mais segura).


2. Se trimming for usado, adicionar regras de preservação (linker config) para: assemblies do Core tipos descobertos por reflexão (mínimo necessário)


3. Registrar a decisão no RELATORIO.md com motivo e validação (teste que prova que não quebrou).



DOCUMENTAÇÃO FINAL (OBRIGATÓRIA) Criar docs:

1. docs/USO_ANDROID.md: instalação do APK primeira execução (instalação do Content.zip) explicar permissões mínimas como iniciar jogo como usar controles na tela como export/import saves notas de áudio (FMOD) fullscreen/landscape


2. docs/LOGS.md: onde ficam logs como exportar via UI (SAF) como puxar via ADB: adb pull /sdcard/Android/data/Celestemeown.app/files/Celeste/Logs/ como interpretar session vs crash


3. docs/TROUBLESHOOTING.md: problemas comuns: download falha extração falha CheckContent falha FMOD não carrega libs/bancos crash ao iniciar input não reconhece controle fullscreen volta com barras Para cada problema: sintoma causa provável como reproduzir onde olhar logs correção aplicada como validar



COMANDOS DE BUILD (CHECKLIST OBRIGATÓRIO) Build Release deve passar: dotnet build src/Celeste.Core -c Release dotnet build src/Celeste.Android -c Release

Publish deve gerar APK: dotnet publish src/Celeste.Android -c Release

ETAPAS OBRIGATÓRIAS (EXECUTAR NA ORDEM, SEM PEDIR CONFIRMAÇÃO)

ETAPA 0 — Auditoria e plano (OBRIGATÓRIO) 0.1 Listar árvore do repositório atual. 0.2 Identificar csproj existentes, net45/x86, refs XNA e pontos de migração. 0.3 Mapear IO: Monocle/Engine.cs (ContentDirectory/Assembly.Location) Monocle/Atlas.cs (bin/data/meta + png) Dialog/Font loaders 0.4 Mapear XNB: Monocle/VirtualTexture.cs Monocle/Draw.cs Celeste/GFX.cs 0.5 Mapear áudio: Celeste/Audio.cs pasta de bancos como o path é construído 0.6 Mapear input: Monocle/MInput.cs Celeste/Input.cs Celeste/Settings.cs 0.7 Mapear reflexão: Overworld.cs e outros pontos (Commands/Tracker/Pooler/SpawnManager etc.) 0.8 Mapear saves: Celeste/UserIO.cs 0.9 Escrever no RELATORIO.md: diagnóstico riscos decisões iniciais (Content.zip, XNB filesystem, paths, FMOD, trimming) plano de execução

ETAPA 1 — Criar solution e projetos (SEM DESKTOP) 1.1 dotnet new sln -n Celeste 1.2 dotnet new classlib -n Celeste.Core -o src/Celeste.Core 1.3 dotnet new mgandroid -n Celeste.Android -o src/Celeste.Android 1.4 Adicionar projetos na solution e referência do Core no Android. 1.5 Configurar ApplicationId = Celestemeown.app e label “Celeste”. 1.6 Configurar arm64-v8a only. 1.7 Build inicial e registrar no RELATORIO.md.

ETAPA 2 — Migrar código do jogo para Core 2.1 Mover Celeste/, Monocle/, SimplexNoise/, FMOD/, FMOD.Studio/ para src/Celeste.Core/ 2.2 Remover csproj antigo net45/x86 e referências XNA antigas. 2.3 Corrigir build do Core sem remover lógica. 2.4 Registrar tudo no RELATORIO.md.

ETAPA 3 — Serviços de plataforma + Paths + LogSystem base 3.1 Criar interfaces no Core: IPlatformPaths, ILogSystem, IAssetLocator, (opcional) IDeviceInfo 3.2 Implementar LogSystem Core (níveis, buffer, formatação, contexto). 3.3 Implementar writer Android (arquivo em LogsRoot) e bootstrap no início do app. 3.4 Capturar exceptions C# e gerar crash logs. 3.5 Ajustar UserIO/Saves para usar Paths do serviço. 3.6 Ajustar Engine.ContentDirectory para ContentRoot instalado via serviço. 3.7 Registrar.

ETAPA 4 — Integração Flutter Add-to-App + Host Kotlin 4.1 Criar módulo Flutter (Add-to-App) e integrar no projeto Android. 4.2 Implementar MainLauncherActivity Kotlin com FlutterEngine e MethodChannel. 4.3 Implementar UI Flutter (dark/landscape/fullscreen) com cards e descrições. 4.4 Implementar métodos base no channel: status, instalar assets, export/import, start game, toggles. 4.5 Registrar.

ETAPA 5 — Instalador de assets (Content.zip) + CheckContent forte 5.1 Implementar AssetInstaller Kotlin: download, progresso, unzip seguro, validação. 5.2 Definir ContentRoot final e persistir estado. 5.3 Implementar “Reinstalar Assets”. 5.4 Implementar CheckContent com lista mínima baseada na auditoria. 5.5 LogSystem deve logar cada etapa. 5.6 Registrar.

ETAPA 6 — XNB no filesystem + File IO alinhado ao ContentRoot instalado 6.1 Implementar ExternalFileContentManager no C# para XNB via FileStream. 6.2 Ajustar Engine/Monocle para usar esse ContentManager e ContentRoot instalado. 6.3 Validar VirtualTexture/Draw/GFX. 6.4 Logar falhas com detalhes. 6.5 Registrar.

ETAPA 7 — Fullscreen + resolução nativa + FPS counter + controles na tela (opcionais) 7.1 Fullscreen Kotlin: immersive sticky reaplicado. 7.2 Fullscreen MonoGame: garantir sem barras e com backbuffer/viewport correto. 7.3 Implementar FPS overlay (toggle via UI). 7.4 Implementar overlay de controles na tela (toggle + config via UI). 7.5 Registrar.

ETAPA 8 — FMOD Android arm64 + bancos no content instalado + lifecycle 8.1 Integrar libs .so arm64-v8a do pacote FMOD fornecido (somente arm64). 8.2 Ajustar paths de bancos (Audio.cs) para o diretório real extraído. 8.3 Implementar pause/resume do áudio. 8.4 Log detalhado de init e erros. 8.5 Registrar.

ETAPA 9 — SAF export/import de saves e export de logs 9.1 Export saves (zip) via ACTION_CREATE_DOCUMENT. 9.2 Import saves (zip) via ACTION_OPEN_DOCUMENT com confirmação. 9.3 Export logs (zip) via ACTION_CREATE_DOCUMENT. 9.4 Registrar.

ETAPA 10 — Reflexão/linker/trimming + robustez + bugfix loop + docs 10.1 Ajustar build para não quebrar reflexão (desativar trimming ou preservar tipos). 10.2 Rodar bugfix loop: instalar assets iniciar jogo validar input físico validar FMOD validar fullscreen após pause/resume validar logs e crash logs validar export/import 10.3 Atualizar docs finais. 10.4 Checklist final no RELATORIO.md.

CHECKLIST FINAL (OBRIGATÓRIO)

1. dotnet build src/Celeste.Core -c Release passa


2. dotnet build src/Celeste.Android -c Release passa


3. dotnet publish src/Celeste.Android -c Release gera APK


4. AndroidSupportedAbis = arm64-v8a apenas


5. Package/ApplicationId = Celestemeown.app e label “Celeste”


6. UI Flutter dark + landscape + fullscreen com cards/descrições


7. Fluxo de assets: baixa Content.zip mostra progresso unzip seguro CheckContent forte habilita “Iniciar Jogo” somente após validação


8. Jogo inicia apenas por botão “Iniciar Jogo”


9. XNB via ContentManager funcionando a partir do filesystem instalado


10. File IO direto funcionando a partir do ContentRoot instalado


11. FMOD funcionando (música e SFX) com libs arm64 e bancos no filesystem


12. LogSystem completo (boot/runtime/crash) persistente e exportável


13. FPS counter toggle funciona


14. Export/Import saves via SAF funciona


15. Export logs via SAF funciona


16. Um único RELATORIO.md atualizado continuamente


17. docs/USO_ANDROID.md, docs/LOGS.md, docs/TROUBLESHOOTING.md completos



INÍCIO IMEDIATO Comece pela ETAPA 0 (auditoria) e siga até concluir tudo, sem pedir confirmação.

Observação operacional obrigatória: Sempre que criar/alterar um arquivo durante a execução, você deve imprimir o conteúdo final completo (sem truncar) e registrar a mudança no RELATORIO.md. Se remover algo, listar e justificar no RELATORIO.md.